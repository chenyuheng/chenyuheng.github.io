# 使用机器学习来自动分析恶意软件的行为

Rieck, Konrad & Trinius, Philipp & Willems, Carsten & Holz, Thorsten. (2011). Automatic analysis of malware behavior using machine learning. Journal of Computer Security. 19. 639-668. 10.3233/JCS-2010-0410. 

阅读这篇文章做的笔记，只做了实现相关的原理的笔记，后面的评估、应用之类的介绍就没做了。

## 简介

恶意软件太多了，静态分析无法应对简单的恶意软件保护措施，动态分析如果依赖人工分析的话工作量太大。本文尝试使用机器学习的方法来自动对恶意软件进行动态分析（行为分析）。

## 怎么做？

1. 沙盒中监控行为（系统调用），获取行为序列报告。
2. 词嵌入，把行为序列报告转换为高维的向量空间中的向量。
3. 使用向量空间中的几何距离训练聚类与分类的机器学习模型。
4. 训练好后增量的检测也可以用了。

### 监控恶意软件行为

#### 使用沙盒

将待分析软件当成一个黑箱，放进可控的操作系统环境（沙盒）然后运行软件。软件所有的系统调用都会被沙盒环境监测并记录下来。

#### 恶意软件指令集

传统的沙盒动态分析会输出 XML 形式的行为报告，对人类的可读性比较好，但不适合机器学习。因此文章介绍了 MIST——所谓的恶意软件指令集——形式的恶意软件行为报告，简单来说，对于每一次系统调用，MIST 将系统调用的种类与名称放在最开始，将其他的相关参数按重要性递减的顺序放在后面；报告记录的内容也不是人类可读的字符串，而是一系列的 ID，通过另外的映射表维护 ID 到具体的值之间的关系。

### 恶意软件行为的词嵌入

进行聚类需要定义两个恶意软件的行为报告之间的“距离”，因此本文借鉴了自然语言处理中的“词嵌入”来将 MIST 形式的行为报告映射到某个向量空间中，进而可以计算距离。

#### 使用指令的 Q-grams 来进行词嵌入

Q-grams 将一个完整的恶意软件指令序列转换为固定长度的序列切片。例如，对于长度为 4 的完整指令序列，以定长 2 进行转换：
$$
[a_1,a_2,a_3,a_4]\\
\downarrow\\
[[a_1,a_2],[a_2,a_3],[a_3,a_4]]
$$
每一个代码片段可能代表一个恶意软件的“指令模式”。然后对于每个可能的指令模式 s，使其成为一个维度，并且用如下公式进行转换：
$$
\phi_s(x)=\left\{\begin{array}{rcl}1 & & {if\ s\ in\ report\ x}\\0 & & {if\ s\ not\ in\ report\ x}\end{array}\right.
$$

文章中的公式 (3) 已经举了一个例子了。

这样的词嵌入可能产生的维度数量特别巨大，不利于计算，然而产生的向量是稀疏的，因此实际上还是好算的。

就此已经完成基本的词嵌入，不过还有一个问题。那就是对于总序列长度较小的行为报告，转换之后的向量长度也比其他的行为报告要小，所以总的序列长度而不是具体的序列主导了转换之后向量的位置。我们希望向量之间的距离主要与行为报告之间的相似度相关，而不是长度，因此使用“正规化函数”将所有转换之后的向量正规化成单位向量，以减小行为报告长度的影响。

#### 计算距离

完成词嵌入之后，计算距离就很简单了。直接上勾股定理，就可以轻松地算出两个向量之间的几何距离，或者叫欧氏距离。由于词嵌入函数没有产生负的向量分量，因此所有向量都分布在第一象限（高维空间应该也是类似的名称吧）；又因为向量都是单位向量，因此任意两个向量之间的距离最低为 0（重合），最高为 $\sqrt{2}$。

### 聚类与分类

经典的分层聚类就很适合这个问题，但计算量太大了。本文使用基于原型的分层聚类，在不太影响聚类效果的情况下节省计算量。

#### 原型提取

以尽量分散的算法选取若干个原型。

#### 使用原型聚类

首先把原型使用分层聚类合并，然后对于每个非原型点，分配到离它最近的原型聚类。

#### 使用原型分类

对于给定需要判断的点，找到离它最近的原型点，计算他到原型点的距离，如果不超过设定的值则接受，否则拒绝。

#### 增量分析

似乎用不上，不仔细看了。说的是该工具在工业界日常使用应该如何维护。



